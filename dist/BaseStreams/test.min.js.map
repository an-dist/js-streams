{
  "version": 3,
  "sources": ["test.ts"],
  "sourcesContent": ["import { BaseDecoder, BaseEncoder, BaseType } from \"./BaseStreams.ts\"\nimport { Utf8DecoderStream, Utf8EncoderStream } from \"../Utf8Streams/Utf8Streams.ts\"\nimport { PerformanceStreamBuilder } from \"../PerformanceStream/PerformanceStream.ts\"\nimport { sleep } from \"../funcs/sleep/sleep.ts\"\n\nconst textSource = (data: string[]) => new ReadableStream<string>({\n  start(controller) {\n    for (const d of data) {\n      controller.enqueue(d)\n    }\n    controller.close()\n  }\n})\n\nconst binarySource = (data: Uint8Array, repeat: number) => new ReadableStream<Uint8Array>({\n  start(controller) {\n    for (let i = 0; i < repeat; ++i) {\n      controller.enqueue(data)\n    }\n    controller.close()\n  }\n})\n\nconst peek = (result: { encoded: string }) => new TransformStream({\n  transform(chunk, controller) {\n    result.encoded += chunk\n    controller.enqueue(chunk)\n  }\n})\n\nconst terminate = (result: { decoded: string | Array<number> }) => new WritableStream({\n  write(chunk) {\n    if (typeof result.decoded === \"string\") {\n      result.decoded += chunk\n    }\n    else {\n      result.decoded = result.decoded.concat([...chunk])\n    }\n  }\n})\n\nconst testText = async (mode: BaseType, data: string[]) => {\n  console.group(\"Testing(text):\", mode)\n\n  const result = {\n    encoded: \"\",\n    decoded: \"\",\n  }\n\n  await textSource(data)\n    .pipeThrough(new Utf8EncoderStream())\n    .pipeThrough(new BaseEncoder(mode).transformable())\n    .pipeThrough(peek(result))\n    .pipeThrough(new BaseDecoder(mode).transformable())\n    .pipeThrough(new Utf8DecoderStream())\n    .pipeTo(terminate(result))\n\n  console.log(\"source:\", data.join(\"\"), \"(\", data.join(\"\").length, \")\")\n  console.log(`${mode}:`, result.encoded, \"(\", result.encoded.length, \")\")\n  console.log(\"decoded:\", result.decoded, \"(\", result.decoded.length, \")\")\n  console.assert(\n    result.decoded === data.join(\"\"),\n    \"data=[\", JSON.stringify(data.join(\"\")), \"](\", data.join(\"\").length, \")\",\n    \"result=[\", JSON.stringify(result.decoded), \"](\", result.decoded.length, \"),\",\n  )\n  console.groupEnd()\n}\n\nconst testBinary = async (mode: BaseType, data: Uint8Array, repeat: number) => {\n  console.group(\"Testing(binary):\", mode, \", repeat=\", repeat)\n\n  const result = {\n    encoded: \"\",\n    decoded: [],\n  }\n\n  const encodePerf = new PerformanceStreamBuilder(\"encode_perf\", \"encode_start\", \"encode_end\")\n  const decodePerf = new PerformanceStreamBuilder(\"decode_perf\", \"decode_start\", \"decode_end\")\n\n  await binarySource(data, repeat)\n    .pipeThrough(encodePerf.pipe(new BaseEncoder(mode).transformable()).build())\n    .pipeThrough(peek(result))\n    .pipeThrough(decodePerf.pipe(new BaseDecoder(mode).transformable()).build())\n    .pipeTo(terminate(result))\n\n  let arr: number[] = []\n  for (let i = 0; i < repeat; ++i) {\n    arr = arr.concat([...data])\n  }\n  data = new Uint8Array(arr)\n  console.log(\"source:\", \"(\", data.byteLength, \")\")\n  console.log(`${mode}:`, \"(\", result.encoded.length, \")\")\n  console.log(\"decoded:\", \"(\", result.decoded.length, \")\")\n  console.assert(\n    result.decoded.every((x, i) => x === data[i]),\n    \"data=[\", data, \"](\", data.byteLength, \")\",\n    \"result=[\", result.decoded, \"](\", result.decoded.length, \"),\",\n  )\n\n  console.group(\"Encode performance\")\n  console.table(encodePerf.result())\n  console.groupEnd()\n  console.group(\"Decode performance\")\n  console.table(decodePerf.result())\n  console.groupEnd()\n\n  console.groupEnd()\n}\n\nconst testBuiltinBase64 = async (data: Uint8Array, repeat: number) => {\n  console.group(\"Testing(Builtin base64):\", \", repeat=\", repeat)\n\n  const result = {\n    encoded: \"\",\n    decoded: [],\n  }\n\n  const encodePerf = new PerformanceStreamBuilder(\"encode_perf\", \"encode_start\", \"encode_end\")\n  const decodePerf = new PerformanceStreamBuilder(\"decode_perf\", \"decode_start\", \"decode_end\")\n\n  await binarySource(data, repeat)\n    .pipeThrough(new TransformStream<Uint8Array, string>({\n      transform(chunk, controller) {\n        let s = \"\"\n        for (let i = 0; i < chunk.byteLength; ++i) {\n          s += String.fromCharCode(chunk[i])\n        }\n        controller.enqueue(s)\n      }\n    }))\n    .pipeThrough(encodePerf.pipe(new TransformStream<string, string>({\n      transform(chunk, controller) {\n        controller.enqueue(btoa(chunk))\n      }\n    })).build())\n    .pipeThrough(peek(result))\n    .pipeThrough(decodePerf.pipe(new TransformStream<string, string>({\n      transform(chunk, controller) {\n        controller.enqueue(atob(chunk))\n      }\n    })).build())\n    .pipeThrough(new TransformStream<string, Uint8Array>({\n      transform(chunk, controller) {\n        const buffer: number[] = []\n        for (let i = 0; i < chunk.length; ++i) {\n          buffer.push(chunk[i].charCodeAt(0))\n        }\n        controller.enqueue(new Uint8Array(buffer))\n      }\n    }))\n    .pipeTo(terminate(result))\n\n  let arr: number[] = []\n  for (let i = 0; i < repeat; ++i) {\n    arr = arr.concat([...data])\n  }\n  data = new Uint8Array(arr)\n  console.log(\"source:\", \"(\", data.byteLength, \")\")\n  console.log(\"base64(builtin):\", \"(\", result.encoded.length, \")\")\n  console.log(\"decoded:\", \"(\", result.decoded.length, \")\")\n  console.assert(\n    result.decoded.every((x, i) => x === data[i]),\n    \"data=[\", data, \"](\", data.byteLength, \")\",\n    \"result=[\", result.decoded, \"](\", result.decoded.length, \"),\",\n  )\n\n  console.group(\"Encode performance\")\n  console.table(encodePerf.result())\n  console.groupEnd()\n  console.group(\"Decode performance\")\n  console.table(decodePerf.result())\n  console.groupEnd()\n\n  console.groupEnd()\n}\n\nconst modes: BaseType[] = [\n  \"base16\",\n  \"base32\",\n  \"base32hex\",\n  \"base64\",\n  \"base64url\",\n]\n\nconst stringData = [\n  \"Hello, World.\",\n]\n\nconst binaryData = new Uint8Array(8192)\nfor (let i = 0; i < binaryData.byteLength; ++i) {\n  binaryData[i] = Math.random() * 0xff\n}\n\nfor (const mode of modes) {\n  await testText(mode, stringData)\n  await sleep()\n  await testBinary(mode, binaryData, 3)\n  await sleep()\n}\nawait testBuiltinBase64(binaryData, 3)\n\nconsole.log(\"Test completed.\")"],
  "mappings": "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",
  "names": ["BaseDecoder", "BaseEncoder", "Utf8DecoderStream", "Utf8EncoderStream", "PerformanceStreamBuilder", "sleep", "textSource", "data", "controller", "d", "binarySource", "repeat", "i", "peek", "result", "chunk", "terminate", "testText", "mode", "testBinary", "encodePerf", "decodePerf", "arr", "x", "testBuiltinBase64", "s", "buffer", "modes", "stringData", "binaryData"]
}
