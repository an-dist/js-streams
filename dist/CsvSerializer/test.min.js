import{CsvSerializer as o}from"./CsvSerializer.min.js";import{sleep as l}from"../funcs/sleep/sleep.min.js";const r=e=>new ReadableStream({start(a){a.enqueue(e),a.close()}}),t=()=>new TransformStream({transform(e,a){console.log(e),a.enqueue(e)}}),n=()=>new WritableStream,p=[{a:1,b:2,c:`aaa
bbb,ccc`},{a:4,b:5,c:6},{a:7,b:8,c:9},{c1:"a",c2:"b",c3:"c",c4:"d"}];console.group("=== escape: all ==="),await r(p).pipeThrough(new o({escape:"all"}).transformable()).pipeThrough(t()).pipeTo(n()),console.groupEnd(),console.group("=== escape: auto ==="),await r(p).pipeThrough(new o({escape:"auto"}).transformable()).pipeThrough(t()).pipeTo(n()),console.groupEnd(),console.group("=== escape: none ==="),await r(p).pipeThrough(new o({escape:"none"}).transformable()).pipeThrough(t()).pipeTo(n()),console.groupEnd(),console.group("=== escape: custom ==="),await r(p).pipeThrough(new o({escape:e=>`[${e}]`}).transformable()).pipeThrough(t()).pipeTo(n()),console.groupEnd(),console.group("=== delimiter: custom ==="),await r(p).pipeThrough(new o({delimiter:"|"}).transformable()).pipeThrough(t()).pipeTo(n()),console.groupEnd(),console.group("=== newLine: custom ==="),await r(p).pipeThrough(new o({newLine:"|"}).transformable()).pipeThrough(t()).pipeTo(n()),console.groupEnd(),console.group("=== no new line ===");let s="";await r(p).pipeThrough(new o({withNewLine:!1}).transformable()).pipeTo(new WritableStream({write(e){s+=e}})),console.log(s),console.groupEnd(),await l(),console.group("Performance test");{console.log("count",1e5);const a=[];for(let c=0;c<1e5;++c)a.push(`{ "a": ${c+1}, "b": ${c+2}, "c": "aaa
bbb,ccc" }`);performance.mark("start"),await r(a).pipeThrough(new o().transformable()).pipeTo(n()),performance.mark("end"),performance.measure("perf","start","end");const i=performance.getEntriesByName("perf")[0];console.log("duration: ",i.duration)}console.groupEnd(),console.log(`
Test completed.`);
//# sourceMappingURL=test.min.js.map
