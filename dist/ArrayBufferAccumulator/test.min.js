import{ArrayBufferAccumulator as l}from"./ArrayBufferAccumulator.min.js";import{PerformanceStreamBuilder as p}from"../PerformanceStream/PerformanceStream.min.js";import{Utf8DecoderStream as d,Utf8EncoderStream as m}from"../Utf8Streams/Utf8Streams.min.js";import{sleep as g}from"../funcs/sleep/sleep.min.js";function f(o,e,r){return new ReadableStream({start(n){const t=new ArrayBuffer(o),i=t.byteLength/e;for(let a=0;a<i;++a){const s=new Uint8Array(t.slice(a*e,a*e+e));if(r){const c=Array.from(s.values());n.enqueue(c)}else n.enqueue(s)}n.close()}})}function w(o){return new WritableStream({write(e){Array.isArray(e)?o.sizeOfWritten+=e.length:o.sizeOfWritten+=e.byteLength}})}function b(o,e){return new TransformStream({transform(r,n){let t;Array.isArray(r)?t=r.length:t=r.byteLength,console.assert([o,e,o-e*Math.floor(o/e)].indexOf(t)!==-1,{receivedChunkSize:t}),n.enqueue(r)}})}const y=async(o,e,r,n,t)=>{e=e===0?o:e;const i=new p("ArrayBufferAccumulator","start","end"),a={sizeOfWritten:0};await f(o,e,t).pipeThrough(i.pipe(new l(r,{fixed:n}).transform()).build()).pipeThrough(b(o,r)).pipeTo(w(a));const s=i.result();console.assert(s!==void 0),console.groupCollapsed([`ReadableStream(${o.toLocaleString()}, { isArray: ${t} }) =>`,`chunk(${e.toLocaleString()}) =>`,`ArrayBufferAccumulator(${r.toLocaleString()}, { fixed: ${n} })`,`durationOfOccupancy: ${s.occupancy}`].join(" ")),console.assert((n?r*Math.ceil(o/r):o)===a.sizeOfWritten,{sizeOfWritten:a.sizeOfWritten});const c={totalSize:o,readableChunkSize:e,chunkSize:r,sizeOfWritten:a.sizeOfWritten,transforming:s.transforming,durationOfOccupancy:s.occupancy,durationMinimum:s.maximum,durationMaximum:s.maximum,durationAverage:s.average,durationMedian:s.median};return console.table(c),console.groupEnd(),await g(),c},u=async o=>{const e=`aaaaaaaaaa
bbbbbbbbbb
cccccccccc
dddddddddd
eeeeeeeeee
11111`,r=new ReadableStream({start(t){t.enqueue(e),t.close()}}),n=new WritableStream({write(t){console.log(`[${t}]`)}});await r.pipeThrough(new m).pipeThrough(new l(o,{forceEmit:[[10,13],[13],[10]]}).transform()).pipeThrough(new d).pipeTo(n)};await f(1,1,!1).pipeThrough(new l(1).transform()).pipeTo(new WritableStream);const A=[1,1e3,1*1024*1024],T=[64,1e3,8192,8192*10,0],O=[128,256,512,1e3,8192];console.group("Testing ArrayBuffer|Array");for(const o of A){console.group(`totalSize: ${o}`);let e,r;console.groupCollapsed("Tests");for(const n of T)for(const t of O)for(const i of[!1,!0])for(const a of[!1,!0]){const s=await y(o,n,t,i,a);(!e||e.perf.durationMaximum<s.durationMaximum)&&(e={totalSize:o,readableChunkSize:n===0?o:n,chunkSize:t,fixed:i,isArray:a,perf:s}),(!r||r.perf.durationMaximum<s.durationMaximum)&&(r={totalSize:o,readableChunkSize:n===0?o:n,chunkSize:t,fixed:i,isArray:a,perf:s})}console.groupEnd(),console.group("Fastest"),console.table(e),console.groupEnd(),console.group("Slowest"),console.table(r),console.groupEnd(),console.groupEnd()}console.groupEnd(),console.groupCollapsed("Testing line separate"),console.groupCollapsed("> size"),await u(8),console.groupEnd(),console.groupCollapsed("= size"),await u(10),console.groupEnd(),console.groupCollapsed("< size"),await u(13),console.groupEnd(),console.groupEnd(),console.log("Test completed.");
//# sourceMappingURL=test.min.js.map
