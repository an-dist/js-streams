{
  "version": 3,
  "sources": ["test.ts"],
  "sourcesContent": ["import { ArrayBufferAccumulator } from \"../ArrayBufferAccumulator.ts\"\r\nimport { PerformanceStreamBuilder } from \"../../PerformanceStream/PerformanceStream.ts\"\r\nimport { Utf8DecoderStream, Utf8EncoderStream } from \"../../Utf8Streams/Utf8Streams.ts\"\r\nimport { sleep } from \"../../funcs/sleep/sleep.ts\"\r\n\r\nfunction source(totalSize: number, chunkSize: number, isArray: boolean) {\r\n  return new ReadableStream<Uint8Array | Array<number>>({\r\n    start(controller) {\r\n      const bytes = new ArrayBuffer(totalSize)\r\n      const count = bytes.byteLength / chunkSize\r\n      for (let i = 0; i < count; ++i) {\r\n        const bytesView = new Uint8Array(bytes.slice(i * chunkSize, i * chunkSize + chunkSize))\r\n        if (isArray) {\r\n          const array = Array.from(bytesView.values())\r\n          controller.enqueue(array)\r\n        }\r\n        else {\r\n          controller.enqueue(bytesView)\r\n        }\r\n      }\r\n      controller.close()\r\n    }\r\n  })\r\n}\r\n\r\ninterface WritableResult {\r\n  sizeOfWritten: number\r\n}\r\n\r\nfunction results<T extends ArrayBufferLike | ArrayLike<any>>(result: WritableResult) {\r\n  return new WritableStream<T>({\r\n    write(chunk) {\r\n      if (Array.isArray(chunk)) {\r\n        result.sizeOfWritten += chunk.length\r\n      }\r\n      else {\r\n        result.sizeOfWritten += (chunk as ArrayBufferLike).byteLength\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nfunction assertChunkSize<T extends ArrayBufferLike | ArrayLike<any>>(totalSize: number, chunkSize: number) {\r\n  return new TransformStream<T, T>({\r\n    transform(chunk, controller) {\r\n      let length: number\r\n      if (Array.isArray(chunk)) {\r\n        length = chunk.length\r\n      }\r\n      else {\r\n        length = (chunk as ArrayBufferLike).byteLength\r\n      }\r\n      console.assert([\r\n        totalSize,\r\n        chunkSize,\r\n        totalSize - (chunkSize * Math.floor(totalSize / chunkSize)),\r\n      ].indexOf(length) !== -1, {\r\n        receivedChunkSize: length,\r\n      })\r\n      controller.enqueue(chunk)\r\n    }\r\n  })\r\n}\r\n\r\nconst test = async (totalSize: number, readableChunkSize: number, chunkSize: number, fixed: boolean, isArray: boolean) => {\r\n  readableChunkSize = readableChunkSize === 0 ? totalSize : readableChunkSize\r\n\r\n  const builder = new PerformanceStreamBuilder<Uint8Array | number[], Uint8Array | number[]>(\"ArrayBufferAccumulator\", \"start\", \"end\")\r\n  const result: WritableResult = { sizeOfWritten: 0 }\r\n\r\n  await source(totalSize, readableChunkSize, isArray)\r\n    .pipeThrough(builder\r\n      .pipe(new ArrayBufferAccumulator(chunkSize, { fixed }).transform())\r\n      .build())\r\n    .pipeThrough(assertChunkSize(totalSize, chunkSize))\r\n    .pipeTo(results(result))\r\n\r\n  const psResult = builder.result()\r\n  console.assert(psResult !== undefined)\r\n\r\n  console.groupCollapsed([\r\n    `ReadableStream(${totalSize.toLocaleString()}, { isArray: ${isArray} }) =>`,\r\n    `chunk(${readableChunkSize.toLocaleString()}) =>`,\r\n    `ArrayBufferAccumulator(${chunkSize.toLocaleString()}, { fixed: ${fixed} })`,\r\n    `durationOfOccupancy: ${psResult!.occupancy}`,\r\n  ].join(\" \"))\r\n\r\n  console.assert((fixed\r\n    ? chunkSize * Math.ceil(totalSize / chunkSize)\r\n    : totalSize) === result.sizeOfWritten, {\r\n    sizeOfWritten: result.sizeOfWritten,\r\n  })\r\n\r\n  console.table({\r\n    totalSize,\r\n    readableChunkSize,\r\n    chunkSize,\r\n    sizeOfWritten: result.sizeOfWritten,\r\n    transforming: psResult!.transforming,\r\n    durationOfOccupancy: psResult!.occupancy,\r\n    durationMinimum: psResult!.maximum,\r\n    durationMaximum: psResult!.maximum,\r\n    durationAverage: psResult!.average,\r\n    durationMedian: psResult!.median,\r\n  })\r\n\r\n  console.groupEnd()\r\n\r\n  await sleep()\r\n}\r\n\r\nconst testNewLine = async (chunkSize: number) => {\r\n  const text = \"aaaaaaaaaa\\nbbbbbbbbbb\\ncccccccccc\\ndddddddddd\\neeeeeeeeee\\n11111\"\r\n\r\n  const readable = new ReadableStream<string>({\r\n    start(controller) {\r\n      controller.enqueue(text)\r\n      controller.close()\r\n    }\r\n  })\r\n\r\n  const writable = new WritableStream({\r\n    write(chunk) {\r\n      console.log(`[${chunk}]`)\r\n    }\r\n  })\r\n\r\n  await readable\r\n    .pipeThrough(new Utf8EncoderStream)\r\n    .pipeThrough(new ArrayBufferAccumulator(chunkSize, { forceEmit: [[10, 13], [13], [10]] }).transform())\r\n    .pipeThrough(new Utf8DecoderStream)\r\n    .pipeTo(writable)\r\n}\r\n\r\n// warmup\r\nawait source(1, 1, false)\r\n  .pipeThrough(new ArrayBufferAccumulator(1).transform())\r\n  .pipeTo(new WritableStream)\r\n\r\nconst totalSizes = [\r\n  1,\r\n  1000,\r\n  1 * 1024 * 1024,\r\n]\r\nconst readableChunkSizes = [\r\n  64,\r\n  1000,\r\n  8192,\r\n  8192 * 10,\r\n  0,\r\n]\r\nconst chunkSizes = [\r\n  128,\r\n  256,\r\n  512,\r\n  1000,\r\n  8192,\r\n]\r\n\r\nconsole.groupCollapsed(\"Testing ArrayBuffer|Array\")\r\nfor (const totalSize of totalSizes) {\r\n  console.groupCollapsed(`totalSize: ${totalSize}`)\r\n  for (const readableChunkSize of readableChunkSizes) {\r\n    for (const chunkSize of chunkSizes) {\r\n      for (const fixed of [false, true]) {\r\n        for (const isArray of [false, true]) {\r\n          await test(totalSize, readableChunkSize, chunkSize, fixed, isArray)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  console.groupEnd()\r\n}\r\nconsole.groupEnd()\r\n\r\nconsole.groupCollapsed(\"Testing line separate\")\r\nconsole.groupCollapsed(\"> size\")\r\nawait testNewLine(8)\r\nconsole.groupEnd()\r\nconsole.groupCollapsed(\"= size\")\r\nawait testNewLine(10)\r\nconsole.groupEnd()\r\nconsole.groupCollapsed(\"< size\")\r\nawait testNewLine(13)\r\nconsole.groupEnd()\r\nconsole.groupEnd()\r\n\r\nconsole.log(\"Test completed.\")"],
  "mappings": "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",
  "names": ["ArrayBufferAccumulator", "PerformanceStreamBuilder", "Utf8DecoderStream", "Utf8EncoderStream", "sleep", "source", "totalSize", "chunkSize", "isArray", "controller", "bytes", "count", "i", "bytesView", "array", "results", "result", "chunk", "assertChunkSize", "length", "test", "readableChunkSize", "fixed", "builder", "psResult", "testNewLine", "text", "readable", "writable", "totalSizes", "readableChunkSizes", "chunkSizes"]
}
