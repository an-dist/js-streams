"use strict";import{ArrayBufferAccumulator as u}from"../ArrayBufferAccumulator.js";import{PerformanceStreamBuilder as m}from"../../PerformanceStream/PerformanceStream.js";import{Utf8DecoderStream as p,Utf8EncoderStream as d}from"../../Utf8Streams/Utf8Streams.js";import{sleep as b}from"../../funcs/sleep/sleep.js";function l(r,e,o){return new ReadableStream({start(t){const n=new ArrayBuffer(r),i=n.byteLength/e;for(let s=0;s<i;++s){const a=new Uint8Array(n.slice(s*e,s*e+e));if(o){const f=Array.from(a.values());t.enqueue(f)}else t.enqueue(a)}t.close()}})}function g(r){return new WritableStream({write(e){Array.isArray(e)?r.sizeOfWritten+=e.length:r.sizeOfWritten+=e.byteLength}})}function y(r,e){return new TransformStream({transform(o,t){let n;Array.isArray(o)?n=o.length:n=o.byteLength,console.assert([r,e,r-e*Math.floor(r/e)].indexOf(n)!==-1,{receivedChunkSize:n}),t.enqueue(o)}})}const w=async(r,e,o,t,n)=>{e=e===0?r:e;const i=new m("ArrayBufferAccumulator","start","end"),s={sizeOfWritten:0};await l(r,e,n).pipeThrough(i.pipe(new u(o,{fixed:t}).transform()).build()).pipeThrough(y(r,o)).pipeTo(g(s));const a=i.result();console.assert(a!==void 0),console.groupCollapsed([`ReadableStream(${r.toLocaleString()}, { isArray: ${n} }) =>`,`chunk(${e.toLocaleString()}) =>`,`ArrayBufferAccumulator(${o.toLocaleString()}, { fixed: ${t} })`,`durationOfOccupancy: ${a.occupancy}`].join(" ")),console.assert((t?o*Math.ceil(r/o):r)===s.sizeOfWritten,{sizeOfWritten:s.sizeOfWritten}),console.table({totalSize:r,readableChunkSize:e,chunkSize:o,sizeOfWritten:s.sizeOfWritten,transforming:a.transforming,durationOfOccupancy:a.occupancy,durationMinimum:a.maximum,durationMaximum:a.maximum,durationAverage:a.average,durationMedian:a.median}),console.groupEnd(),await b()},c=async r=>{const e=`aaaaaaaaaa
bbbbbbbbbb
cccccccccc
dddddddddd
eeeeeeeeee
11111`,o=new ReadableStream({start(n){n.enqueue(e),n.close()}}),t=new WritableStream({write(n){console.log(`[${n}]`)}});await o.pipeThrough(new d).pipeThrough(new u(r,{forceEmit:[[10,13],[13],[10]]}).transform()).pipeThrough(new p).pipeTo(t)};await l(1,1,!1).pipeThrough(new u(1).transform()).pipeTo(new WritableStream);const A=[1,1e3,1*1024*1024],T=[64,1e3,8192,8192*10,0],W=[128,256,512,1e3,8192];console.groupCollapsed("Testing ArrayBuffer|Array");for(const r of A){console.groupCollapsed(`totalSize: ${r}`);for(const e of T)for(const o of W)for(const t of[!1,!0])for(const n of[!1,!0])await w(r,e,o,t,n);console.groupEnd()}console.groupEnd(),console.groupCollapsed("Testing line separate"),console.groupCollapsed("> size"),await c(8),console.groupEnd(),console.groupCollapsed("= size"),await c(10),console.groupEnd(),console.groupCollapsed("< size"),await c(13),console.groupEnd(),console.groupEnd(),console.log("Test completed.");
//# sourceMappingURL=test.js.map
