import{CsvDeserializer as m}from"./CsvDeserializer.min.js";import{PerformanceStreamBuilder as f}from"../PerformanceStream/PerformanceStream.min.js";import{sleep as w}from"../funcs/sleep/sleep.min.js";const i=e=>new ReadableStream({start(o){for(const s of e)o.enqueue(s);o.close()}}),h=()=>new TransformStream({transform(e,o){console.log(e),o.enqueue(e)}}),p=()=>new WritableStream,d=e=>new m(e),c=['a,1,"b,2\\""',"c,3,d,4",`e,5,f
g,6,h`],u=["column1,column2,column3"].concat(c),T=c.map(e=>e.replace(/,/g,"	")),H=u.map(e=>e.replace(/,/g,"	")),a=async(e,o,s,r)=>{console.group(e),console.log("headers=",s),console.log("data=",o),console.log("result="),await i(o).pipeThrough(d({hasHeader:!s||s.length===0,headers:s,delimiter:r}).transformable()).pipeThrough(h()).pipeTo(p()),console.groupEnd()},b=async(e,o)=>{console.group("columns=",e,"rows=",o);const s=[],r=[];for(let n=0;n<e;++n)r.push(`column${n+1}`);s.push(r.join(","));for(let n=0;n<o;++n){r.length=0;for(let t=0;t<e;++t)r.push(`value${n+1}_${t+1}`);s.push(r.join(","))}const l=new f("perf","start","end");await i(s).pipeThrough(l.pipe(d({hasHeader:!0}).transformable()).build()).pipeTo(p());const g=l.result();console.table(g),console.groupEnd()};console.group("Testing"),await a("CSV Header less",c,["c1","c2"]),await a("CSV Header included",u),await a("TSV Header less",T,["c1","c2"],"	"),await a("TSV Header included",H,void 0,"	"),console.groupEnd(),await w(),console.group("Testing performance"),await b(100,1e5),console.groupEnd(),console.log("Test completed.");
//# sourceMappingURL=test.min.js.map
