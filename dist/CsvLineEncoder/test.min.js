import{CsvLineEncoder as o}from"./CsvLineEncoder.min.js";import{sleep as l}from"../funcs/sleep/sleep.min.js";const n=e=>new ReadableStream({start(r){r.enqueue(e),r.close()}}),t=()=>new TransformStream({transform(e,r){console.log(e),r.enqueue(e)}}),a=()=>new WritableStream,p=[{a:1,b:2,c:`aaa
bbb,ccc`},{a:4,b:5,c:6},{a:7,b:8,c:9},{c1:"a",c2:"b",c3:"c",c4:"d"}];console.group("=== escape: all ==="),await n(p).pipeThrough(new o({escape:"all"}).transformable()).pipeThrough(t()).pipeTo(a()),console.groupEnd(),console.group("=== escape: auto ==="),await n(p).pipeThrough(new o({escape:"auto"}).transformable()).pipeThrough(t()).pipeTo(a()),console.groupEnd(),console.group("=== escape: none ==="),await n(p).pipeThrough(new o({escape:"none"}).transformable()).pipeThrough(t()).pipeTo(a()),console.groupEnd(),console.group("=== escape: custom ==="),await n(p).pipeThrough(new o({escape:e=>`[${e}]`}).transformable()).pipeThrough(t()).pipeTo(a()),console.groupEnd(),console.group("=== delimiter: custom ==="),await n(p).pipeThrough(new o({delimiter:"|"}).transformable()).pipeThrough(t()).pipeTo(a()),console.groupEnd(),console.group("=== newLine: custom ==="),await n(p).pipeThrough(new o({newLine:"|"}).transformable()).pipeThrough(t()).pipeTo(a()),console.groupEnd(),console.group("=== no new line ===");let s="";await n(p).pipeThrough(new o({withNewLine:!1}).transformable()).pipeTo(new WritableStream({write(e){s+=e}})),console.log(s),console.groupEnd(),await l(),console.group("Performance test");{console.log("count",1e5);const r=[];for(let c=0;c<1e5;++c)r.push(`{ "a": ${c+1}, "b": ${c+2}, "c": "aaa
bbb,ccc" }`);performance.mark("start"),await n(r).pipeThrough(new o().transformable()).pipeTo(a()),performance.mark("end"),performance.measure("perf","start","end");const i=performance.getEntriesByName("perf")[0];console.log("duration: ",i.duration)}console.groupEnd(),console.log(`
Test completed.`);
//# sourceMappingURL=test.min.js.map
