import{CsvLineEncoder as o}from"./CsvLineEncoder.min.js";const n=e=>new ReadableStream({start(r){r.enqueue(e),r.close()}}),c=()=>new TransformStream({transform(e,r){console.log(e),r.enqueue(e)}}),p=()=>new WritableStream,a=[{a:1,b:2,c:`aaa
bbb,ccc`},{a:4,b:5,c:6},{a:7,b:8,c:9},{c1:"a",c2:"b",c3:"c",c4:"d"}];console.group("=== escape: all ==="),await n(a).pipeThrough(new o({escape:"all"}).transform()).pipeThrough(c()).pipeTo(p()),console.groupEnd(),console.group("=== escape: auto ==="),await n(a).pipeThrough(new o({escape:"auto"}).transform()).pipeThrough(c()).pipeTo(p()),console.groupEnd(),console.group("=== escape: none ==="),await n(a).pipeThrough(new o({escape:"none"}).transform()).pipeThrough(c()).pipeTo(p()),console.groupEnd(),console.group("=== escape: custom ==="),await n(a).pipeThrough(new o({escape:e=>`[${e}]`}).transform()).pipeThrough(c()).pipeTo(p()),console.groupEnd(),console.group("=== delimiter: custom ==="),await n(a).pipeThrough(new o({delimiter:"|"}).transform()).pipeThrough(c()).pipeTo(p()),console.groupEnd(),console.group("=== newLine: custom ==="),await n(a).pipeThrough(new o({newLine:"|"}).transform()).pipeThrough(c()).pipeTo(p()),console.groupEnd(),console.group("=== no new line ===");let s="";await n(a).pipeThrough(new o({withNewLine:!1}).transform()).pipeTo(new WritableStream({write(e){s+=e}})),console.log(s),console.groupEnd(),console.group("Performance test");{console.log("count",1e5);const r=[];for(let t=0;t<1e5;++t)r.push(`{ "a": ${t+1}, "b": ${t+2}, "c": "aaa
bbb,ccc" }`);performance.mark("start"),await n(r).pipeThrough(new o().transform()).pipeTo(p()),performance.mark("end"),performance.measure("perf","start","end");const i=performance.getEntriesByName("perf")[0];console.log("duration: ",i.duration)}console.groupEnd(),console.log(`
Test completed.`);
//# sourceMappingURL=test.min.js.map
